<!DOCTYPE html>
<html>
<head>
    <title>第七章：重定向 - Shell脚本学习 - Shell百科</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="keywords" content="Linux命令行,shell,linux命令大全,shell脚本,shell脚本编程,linux shell,第七章：重定向" />
    <meta name="description" content="这堂课，我们来介绍可能是命令行最酷的特性。它叫做 I/O 重定向。”I/O”代表输入/输出， 通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。 也可以把多个命令连接起来组成一个强大的命令管道。" />
    <link rel="stylesheet" href="../static/css/main.css" tppabs="http://shellbaike.com/static/css/main.css" />
    <link rel="stylesheet" href="../static/css/prism.css" tppabs="http://shellbaike.com/static/css/prism.css" />
</head>
<body>
<div id="header">
    <div class="wrapper">
        <div id="header_top">
            <h1 class="logH1"><a href="javascript:if(confirm('http://shellbaike.com/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/'" tppabs="http://shellbaike.com/" title="Shell百科 最全linux命令大全 Shell脚本编程技巧分享">Shell百科</a></h1>
            <h3 class="logH3"><a href="javascript:if(confirm('http://shellbaike.com/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/'" tppabs="http://shellbaike.com/">shellbaike.com</a></h3>
        </div>
        <div id="header_ad">

        </div>
        <div class="clear"></div>
        <div id="header_nav">
            <ul>
                <li><a href="javascript:if(confirm('http://shellbaike.com/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/'" tppabs="http://shellbaike.com/">首页</a></li>
                <li><a href="javascript:if(confirm('http://shellbaike.com/cmd/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/'" tppabs="http://shellbaike.com/cmd/">Linux命令大全</a></li>
                <li><a href="index.htm" tppabs="http://shellbaike.com/cmdline/">Shell脚本学习</a></li>
                <li><a href="javascript:if(confirm('http://shellbaike.com/shell/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/shell/'" tppabs="http://shellbaike.com/shell/">Shell脚本编程</a></li>
                <li><a href="javascript:if(confirm('http://shellbaike.com/linux/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/linux/'" tppabs="http://shellbaike.com/linux/">Linux资讯</a></li>
            </ul>
        </div>
    </div>
</div>
<div id="main">
    <div class="wrapper">
        <div id="main_left" class="l mainInfo">
            <h1 class="titleInfo">
                第七章：重定向
            </h1>
            <div class="info">
                <span class="smartTime" smartTime="1420088089">2015-01-01 12:54:49 +0800 CST</span>
            </div>
            <div style="text-align: center;">
    
</div>
            <div class="mainContent">
                <p>这堂课，我们来介绍可能是命令行最酷的特性。它叫做 I/O 重定向。”I/O”代表输入/输出， 通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。 也可以把多个命令连接起来组成一个强大的命令管道。为了炫耀这个工具，我们将叙述 以下命令：</p><ul><li><p><a href="javascript:if(confirm('http://shellbaike.com/cmd/cat  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/cat'" tppabs="http://shellbaike.com/cmd/cat" title="cat命令参数">cat</a> － 连接文件</p></li><li><p><a href="javascript:if(confirm('http://shellbaike.com/cmd/sort  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/sort'" tppabs="http://shellbaike.com/cmd/sort" title="sort用法">sort</a> － 排序文本行</p></li><li><p><a href="javascript:if(confirm('http://shellbaike.com/cmd/uniq  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/uniq'" tppabs="http://shellbaike.com/cmd/uniq" title="uniq例子">uniq</a> － 报道或省略重复行</p></li><li><p><a href="javascript:if(confirm('http://shellbaike.com/cmd/grep  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/grep'" tppabs="http://shellbaike.com/cmd/grep" title="grep命令详解">grep</a> － 打印匹配行</p></li><li><p><a href="javascript:if(confirm('http://shellbaike.com/cmd/wc  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/wc'" tppabs="http://shellbaike.com/cmd/wc" title="wc命令参数">wc</a> － 打印文件中换行符，字，和字节个数</p></li><li><p><a href="javascript:if(confirm('http://shellbaike.com/cmd/head  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/head'" tppabs="http://shellbaike.com/cmd/head" title="head用法">head</a> － 输出文件第一部分</p></li><li><p><a href="javascript:if(confirm('http://shellbaike.com/cmd/tail  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/tail'" tppabs="http://shellbaike.com/cmd/tail" title="tail例子">tail</a> - 输出文件最后一部分</p></li></ul><h3>标准输入，输出，和错误</h3><p>到目前为止，我们用到的许多程序都会产生某种输出。这种输出，经常由两种类型组成。 第一，程序运行结果；这是说，程序要完成的功能。第二，我们得到状态和错误信息， 这些告诉我们程序进展。如果我们观察一个命令，像 <a href="javascript:if(confirm('http://shellbaike.com/cmd/ls  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/ls'" tppabs="http://shellbaike.com/cmd/ls" title="ls命令详解">ls</a>，会看到它的运行结果和错误信息 显示在屏幕上。</p><p>与 Unix 主题“任何东西都是一个文件”保持一致，程序，比方说 ls，实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。</p><p>I/O 重定向允许我们可以更改输出走向和输入来向。一般地，输出送到屏幕，输入来自键盘， 但是通过 I/O 重定向，我们可以改变输入输出方向。</p><h3>重定向标准输出</h3><p>I/O 重定向允许我们来重定义标准输出送到哪里。重定向标准输出到另一个文件除了屏幕，我们使用 “&gt;” 重定向符，其后跟着文件名。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去， 由文件代替屏幕。</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt
</code></pre><p>这里，我们创建了一个长长的目录/usr/bin 列表，并且输送程序运行结果到文件 ls-output.txt 中。 我们检查一下重定向的命令输出结果：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1   me   me    167878 2008-02-01 15:07 ls-output.txt
</code></pre><p>好；一个不错的大型文本文件。如果我们用 <a href="javascript:if(confirm('http://shellbaike.com/cmd/less  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/less'" tppabs="http://shellbaike.com/cmd/less" title="less命令参数">less</a> 阅读器来查看这个文件，我们会看到文件 ls-output.txt 的确包含 ls 命令的执行结果。</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ less ls-output.txt
</code></pre><p>现在，重复我们的重定向测试，但这次有改动。我们把目录换成一个不存在的目录。</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txt
ls: cannot access /bin/usr: No such file or directory
</code></pre><p>我们收到一个错误信息。这很有意义，因为我们指定了一个不存在的目录/bin/usr, 但是为什么这条错误信息显示在屏幕上而不是被重定向到文件 ls-output.txt？答案是， ls 程序不把它的错误信息输送到标准输出。反而，像许多写得不错的 Unix 程序，ls 把 错误信息送到标准错误。因为我们只是重定向了标准输出，而没有重定向标准错误， 所以错误信息被送到屏幕。马上，我们将知道怎样重定向标准错误，但是首先看一下 我们的输出文件发生了什么事情。</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me   me    0 2008-02-01 15:08 ls-output.txt
</code></pre><p>文件长度成为零！这是因为，当我们使用 “&gt;” 重定向符来重定向输出结果时，目标文件总是从开头被重写。 因为我们 ls 命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后 由于错误而停止，导致文件内容删除。事实上，如果我们需要删除一个文件内容（或者创建一个 新的空文件），可以使用这样的技巧：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ &gt; ls-output.txt
</code></pre><p>简单地使用重定向符，没有命令在它之前，这会删除一个已存在文件的内容或是 创建一个新的空文件。</p><p>所以，怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目的， 我们使用”&gt;&gt;“重定向符，像这样：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt
</code></pre><p>使用”&gt;&gt;“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”&gt;”操作符。把它放到测试中：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt
[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me   me    503634 2008-02-01 15:45 ls-output.txt
</code></pre><p>我们重复执行命令三次，导致输出文件大小是原来的三倍。</p><h3>重定向标准错误</h3><p>重定向标准错误缺乏专用的重定向操作符。重定向标准错误，我们必须参考它的文件描述符。 一个程序可以在几个编号的文件流中的任一个上产生输出。然而我们必须把这些文件流的前 三个看作标准输入，输出和错误，shell 内部参考它们为文件描述符0，1和2，各自地。shell 提供 了一种表示法来重定向文件，使用文件描述符。因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /bin/usr 2&gt; ls-error.txt
</code></pre><p>文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。</p><h3>重定向标准输出和错误到同一个文件</h3><p>可能有这种情况，我们希望捕捉一个命令的所有输出到一个文件。为了完成这个，我们 必须同时重定向标准输出和标准错误。有两种方法来完成任务。第一个，传统的方法， 在旧版本 shell 中也有效：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1
</code></pre><p>使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2&gt;&amp;1。</p><hr><p>注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。上面的例子，</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">&gt;ls-output.txt 2&gt;&amp;1
</code></pre><p>重定向标准错误到文件 ls-output.txt，但是如果命令顺序改为：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">2&gt;&amp;1 &gt;ls-output.txt
</code></pre><p>则标准错误定向到屏幕。</p><hr><p>现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /bin/usr &amp;&gt; ls-output.txt
</code></pre><p>在这个例子里面，我们使用单单一个表示法 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt。</p><h3>处理不需要的输出</h3><p>有时候“沉默是金”，我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。系统为我们提供了解决问题的方法，通过重定向输出结果 到一个特殊的叫做”/dev/null”的文件。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，我们这样做：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /bin/usr 2&gt; /dev/null
</code></pre><blockquote><p>Unix 文化中的/dev/null</p><p>位存储桶是个古老的 Unix 概念，由于它的普遍性，它的身影出现在 Unix 文化的 许多部分。当有人说他/她正在发送你的评论到/dev/null，现在你应该知道那是 什么意思了。更多的例子，可以阅读 Wikipedia 关于”/dev/null”的文章。</p></blockquote><h3>重定向标准输入</h3><p>到目前为止，我们还没有遇到一个命令是利用标准输入的（实际上我们遇到过了，但是 一会儿再揭晓谜底），所以我们需要介绍一个。</p><h3>cat － 连接文件</h3><p>cat 命令读取一个或多个文件，然后复制它们到标准输出，就像这样:</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">cat [file]
</code></pre><p>在大多数情况下，你可以认为 cat 命令相似于 DOS 中的 TYPE 命令。你可以使用 cat 来显示 文件而没有分页，例如：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ cat ls-output.txt
</code></pre><p>将会显示文件 ls-output.txt 的内容。cat 经常被用来显示简短的文本文件。因为 cat 可以 接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个 大型文件，这个文件被分离成多个部分（USENET 中的多媒体文件经常以这种方式分离）， 我们想把它们连起来。如果文件命名为：</p><p>我们能用这个命令把它们连接起来：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">cat movie.mpeg.0* &gt; movie.mpeg
</code></pre><p>因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。</p><p>这很好，但是这和标准输入有什么关系呢？没有任何关系，让我们试着做些其他的工作。 如果我们输入不带参数的”cat”命令，会发生什么呢：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ cat
</code></pre><p>没有发生任何事情，它只是坐在那里，好像挂掉了一样。看起来是那样，但是它正在做它该做的事情：</p><p>如果 cat 没有给出任何参数，它会从标准输入读入数据，因为标准输入，默认情况下，连接到键盘。 它正在等待我们输入数据！试试这个：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ cat
The quick brown fox jumped over the lazy dog.
</code></pre><p>下一步，输入 Ctrl-d（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ cat
The quick brown fox jumped over the lazy dog.
</code></pre><p>由于文件名参数的缺席，cat 复制标准输入到标准输出，所以我们看到文本行重复出现。 我们可以使用这种行为来创建简短的文本文件。比方说，我们想创建一个叫做”lazy_dog.txt” 的文件，这个文件包含例子中的文本。我们这样做：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ cat &gt; lazy_dog.txt
The quick brown fox jumped over the lazy dog.
</code></pre><p>输入命令，其后输入要放入文件中的文本。记住，最后输入 Ctrl-d。通过使用这个命令，我们 实现了世界上最低能的文字处理器！看一下运行结果，我们使用 cat 来复制文件内容到 标准输出：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ cat lazy_dog.txt
The quick brown fox jumped over the lazy dog.
</code></pre><p>现在我们知道怎讲接受标准输入，除了文件名参数，让我们试着重定向标准输入：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ cat &lt; lazy_dog.txt
The quick brown fox jumped over the lazy dog.
</code></pre><p>使用“&lt;”重定向操作符，我们把标准输入源从键盘改到文件 lazy_dog.tx。我们看到结果 和传递单个文件名作为参数的执行结果一样。把这和传递一个文件名参数作比较，尤其没有意义， 但它是用来说明把一个文件作为标准输入源。</p><p>在我们继续之前，查看 cat 的手册页，因为它有几个有趣的选项。</p><h3>管道线</h3><p>命令可以从标准输入读取数据，然后再把数据输送到标准输出，命令的这种能力被 一个 shell 特性所利用，这个特性叫做管道线。使用管道操作符”|”（竖杠），一个命令的 标准输出可以管道到另一个命令的标准输入：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">command1 | command2
</code></pre><p>为了全面地说明这个命令，我们需要一些命令。是否记得我们说过，我们已经知道有一个 命令接受标准输入？它是 less 命令。我们用 less 来一页一页地显示任何命令的输出，命令把 它的运行结果输送到标准输出：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls -l /usr/bin | less
</code></pre><p>这极其方便！使用这项技术，我们可以方便地检测会产生标准输出的任一命令的运行结果。</p><h3>过滤器</h3><p>管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。第一个我们想试验的过滤器是 sort。想象一下，我们想把目录/bin 和/usr/bin 中 的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls /bin /usr/bin | sort | less
</code></pre><p>因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个 有序列表。</p><h3>uniq - 报道或忽略重复行</h3><p>uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序 列表（详情查看 uniq 手册页），默认情况下，从数据列表中删除任何重复行。所以，为了确信 我们的列表中不包含重复句子（这是说，出现在目录/bin 和/usr/bin 中重名的程序），我们添加 uniq 到我们的管道线中：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less
</code></pre><p>在这个例子中，我们使用 uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上”-d”选项，就像这样：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d | less
</code></pre><h3>wc － 打印行，字和字节数</h3><p>wc（字计数）命令是用来显示文件所包含的行，字和字节数。例如：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ wc ls-output.txt
7902 64566 503634 ls-output.txt
</code></pre><p>在这个例子中，wc 打印出来三个数字：包含在文件 ls-output.txt 中的行数，单词数和字节数， 正如我们先前的命令，如果 wc 不带命令行参数，它接受标准输入。”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数， 我们可以这样做：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
2728
</code></pre><h3>grep － 打印匹配行</h3><p>grep 是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep 命令：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">grep pattern [file...]
</code></pre><p>当 grep 遇到一个文件中的匹配”模式”，它会打印出包含这个类型的行。grep 能够匹配的模式可以 很复杂，但是现在我们把注意力集中在简单文本匹配上面。在后面的章节中，我们将会研究 高级模式，叫做正则表达式。</p><p>比如说，我们想在我们的程序列表中，找到文件名中包含单词”<a href="javascript:if(confirm('http://shellbaike.com/cmd/zip  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/zip'" tppabs="http://shellbaike.com/cmd/zip" title="zip用法">zip</a>”的所有文件。这样一个搜索， 可能让我们了解系统中的一些程序与文件压缩有关系。这样做：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
...
</code></pre><p>grep 有－对方便的选项：”-i”导致 grep 忽略大小写当执行搜索时（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。</p><h3>head / tail － 打印文件开头部分/结尾部分</h3><p>有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。 head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ head -n 5 ls-output.txt
total 343496
...
[me@linuxbox ~]$ tail -n 5 ls-output.txt
...
</code></pre><p>它们也能用在管道线中：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls /usr/bin | tail -n 5
znew
...
</code></pre><p>tail 有一个选项允许你实时的浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。在以下的例子里，我们要查看目录/var/log 里面的信息文件。在 一些 Linux 发行版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages 可能包含安全信息。</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
....
</code></pre><p>使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。</p><h3>tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件</h3><p>为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 <a href="javascript:if(confirm('http://shellbaike.com/cmd/tee  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/tee'" tppabs="http://shellbaike.com/cmd/tee" title="tee例子">tee</a> 的命令，这个命令制造了 一个”tee”，安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子， 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：</p><pre><code style="font-family: 'Courier New', Courier, monospace; border: none;">[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
</code></pre><h3>总结归纳</h3><p>一如既往，查看这章学到的每一个命令的文档。我们已经知道了他们最基本的用法。 它们还有很多有趣的选项。随着我们 Linux 经验的积累，我们会了解命令行重定向特性 在解决特殊问题时非常有用处。有许多命令利用标准输入和输出，而几乎所有的命令行 程序都使用标准错误来显示它们的详细信息。</p><blockquote><p>Linux 可以激发我们的想象</p><p>当我被要求解释 Windows 与 Linux 之间的差异时，我经常拿玩具来作比喻。</p><p>Windows 就像一个游戏机。你去商店，买了一个包装在盒子里面的全新的游戏机。 你把它带回家，打开盒子，开始玩游戏。精美的画面，动人的声音。玩了一段时间之后， 你厌倦了它自带的游戏，所以你返回商店，又买了另一个游戏机。这个过程反复重复。 最后，你玩腻了游戏机自带的游戏，你回到商店，告诉售货员，“我想要一个这样的游戏！” 但售货员告诉你没有这样的游戏存在，因为它没有“市场需求”。然后你说，“但是我只 需要修改一下这个游戏！“，售货员又告诉你不能修改它。所有游戏都被封装在它们的 存储器中。到头来，你发现你的玩具只局限于别人为你规定好的游戏。</p><p>另一方面，Linux 就像一个全世界上最大的建造模型。你打开它，发现它只是一个巨大的 部件集合。有许多钢支柱，螺钉，螺母，齿轮，滑轮，发动机，和一些怎样来建造它的说明书。 然后你开始摆弄它。你建造了一个又一个样板模型。过了一会儿，你发现你要建造自己的模型。 你不必返回商店，因为你已经拥有了你需要的一切。建造模型以你构想的形状为模板，搭建 你想要的模型。</p><p>当然，选择哪一个玩具，是你的事情，那么你觉得哪个玩具更令人满意呢？</p></blockquote>
            </div>
        </div>
        <div id="main_right" class="r">
            <div class="rightItem">
                <h2>
                    Shell脚本学习目录
                </h2>
                <ul>
                    
                    <li><a href="1.htm" tppabs="http://shellbaike.com/cmdline/1">第一章 引言</a></li>
                    
                    <li><a href="2.htm" tppabs="http://shellbaike.com/cmdline/2">第二章 : 什么是 shell</a></li>
                    
                    <li><a href="3.htm" tppabs="http://shellbaike.com/cmdline/3">第三章：文件系统中跳转</a></li>
                    
                    <li><a href="5.htm" tppabs="http://shellbaike.com/cmdline/5">第四章：探究操作系统</a></li>
                    
                    <li><a href="6.htm" tppabs="http://shellbaike.com/cmdline/6">第五章：操作文件和目录</a></li>
                    
                    <li><a href="7.htm" tppabs="http://shellbaike.com/cmdline/7">第六章：使用命令</a></li>
                    
                    <li><a href="8.htm" tppabs="http://shellbaike.com/cmdline/8">第七章：重定向</a></li>
                    
                    <li><a href="9.htm" tppabs="http://shellbaike.com/cmdline/9">第八章：从 shell 眼中看世界</a></li>
                    
                    <li><a href="10.htm" tppabs="http://shellbaike.com/cmdline/10">第九章：键盘高级操作技巧</a></li>
                    
                    <li><a href="11.htm" tppabs="http://shellbaike.com/cmdline/11">第十章：权限</a></li>
                    
                    <li><a href="12.htm" tppabs="http://shellbaike.com/cmdline/12">第十一章：进程</a></li>
                    
                    <li><a href="15.htm" tppabs="http://shellbaike.com/cmdline/15">第十二章 : shell 环境</a></li>
                    
                    <li><a href="16.htm" tppabs="http://shellbaike.com/cmdline/16">第十三章 : vi 简介</a></li>
                    
                    <li><a href="17.htm" tppabs="http://shellbaike.com/cmdline/17">第十四章 : 自定制 shell 提示符</a></li>
                    
                    <li><a href="18.htm" tppabs="http://shellbaike.com/cmdline/18">第十五章 : 软件包管理</a></li>
                    
                    <li><a href="19.htm" tppabs="http://shellbaike.com/cmdline/19">第十六章 : 存储媒介</a></li>
                    
                    <li><a href="20.htm" tppabs="http://shellbaike.com/cmdline/20">第十七章 : 网络系统</a></li>
                    
                    <li><a href="21.htm" tppabs="http://shellbaike.com/cmdline/21">第十八章 : 查找文件</a></li>
                    
                    <li><a href="22.htm" tppabs="http://shellbaike.com/cmdline/22">第十九章 : 归档和备份</a></li>
                    
                    <li><a href="23.htm" tppabs="http://shellbaike.com/cmdline/23">第二十章 : 正则表达式</a></li>
                    
                    <li><a href="24.htm" tppabs="http://shellbaike.com/cmdline/24">第二十一章 : 文本处理</a></li>
                    
                    <li><a href="25.htm" tppabs="http://shellbaike.com/cmdline/25">第二十二章 : 格式化输出</a></li>
                    
                    <li><a href="26.htm" tppabs="http://shellbaike.com/cmdline/26">第二十三章 : 打印</a></li>
                    
                    <li><a href="27.htm" tppabs="http://shellbaike.com/cmdline/27">第二十四章 : 编译程序</a></li>
                    
                    <li><a href="28.htm" tppabs="http://shellbaike.com/cmdline/28">第二十五章 : 编写第一个 Shell 脚本</a></li>
                    
                    <li><a href="29.htm" tppabs="http://shellbaike.com/cmdline/29">第二十六章 : 启动一个项目</a></li>
                    
                    <li><a href="30.htm" tppabs="http://shellbaike.com/cmdline/30">第二十七章 : 自顶向下设计</a></li>
                    
                    <li><a href="31.htm" tppabs="http://shellbaike.com/cmdline/31">第二十八章 : 流程控制：if 分支结构</a></li>
                    
                    <li><a href="32.htm" tppabs="http://shellbaike.com/cmdline/32">第二十九章 : 读取键盘输入</a></li>
                    
                    <li><a href="33.htm" tppabs="http://shellbaike.com/cmdline/33">第三十章 : 流程控制：while/until 循环</a></li>
                    
                    <li><a href="34.htm" tppabs="http://shellbaike.com/cmdline/34">第三十一章 : 疑难排解</a></li>
                    
                    <li><a href="35.htm" tppabs="http://shellbaike.com/cmdline/35">第三十二章 : 流程控制：case 分支</a></li>
                    
                    <li><a href="36.htm" tppabs="http://shellbaike.com/cmdline/36">第三十三章 : 位置参数</a></li>
                    
                    <li><a href="37.htm" tppabs="http://shellbaike.com/cmdline/37">第三十四章 : 流程控制：for 循环</a></li>
                    
                    <li><a href="38.htm" tppabs="http://shellbaike.com/cmdline/38">第三十五章 : 字符串和数字</a></li>
                    
                    <li><a href="39.htm" tppabs="http://shellbaike.com/cmdline/39">第三十六章 : 数组</a></li>
                    
                    <li><a href="40.htm" tppabs="http://shellbaike.com/cmdline/40">第三十七章 : 奇珍异宝</a></li>
                    
                </ul>
            </div>
            <div class="rightItem">
    <h2>
        Shell随机文章
    </h2>
    <ul>
        
        <li><a href="2.htm" tppabs="http://shellbaike.com/cmdline/2">第二章 : 什么是 shell</a></li>
        
        <li><a href="3.htm" tppabs="http://shellbaike.com/cmdline/3">第三章：文件系统中跳转</a></li>
        
        <li><a href="6.htm" tppabs="http://shellbaike.com/cmdline/6">第五章：操作文件和目录</a></li>
        
        <li><a href="7.htm" tppabs="http://shellbaike.com/cmdline/7">第六章：使用命令</a></li>
        
        <li><a href="8.htm" tppabs="http://shellbaike.com/cmdline/8">第七章：重定向</a></li>
        
        <li><a href="9.htm" tppabs="http://shellbaike.com/cmdline/9">第八章：从 shell 眼中看世界</a></li>
        
        <li><a href="10.htm" tppabs="http://shellbaike.com/cmdline/10">第九章：键盘高级操作技巧</a></li>
        
        <li><a href="12.htm" tppabs="http://shellbaike.com/cmdline/12">第十一章：进程</a></li>
        
        <li><a href="javascript:if(confirm('http://shellbaike.com/shell/13  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/shell/13'" tppabs="http://shellbaike.com/shell/13">Linux安装软件</a></li>
        
        <li><a href="16.htm" tppabs="http://shellbaike.com/cmdline/16">第十三章 : vi 简介</a></li>
        
    </ul>
</div>
            <div class="rightItem">
    <h2>
        Linux常用命令
    </h2>
    <ul>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/apmd  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/apmd'" tppabs="http://shellbaike.com/cmd/apmd">apmd</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/apropos  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/apropos'" tppabs="http://shellbaike.com/cmd/apropos">apropos</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/aumix  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/aumix'" tppabs="http://shellbaike.com/cmd/aumix">aumix</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/bg  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/bg'" tppabs="http://shellbaike.com/cmd/bg">bg</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/bzip2  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/bzip2'" tppabs="http://shellbaike.com/cmd/bzip2">bzip2</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/cd  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/cd'" tppabs="http://shellbaike.com/cmd/cd">cd</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/cfdisk  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/cfdisk'" tppabs="http://shellbaike.com/cmd/cfdisk">cfdisk</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/chfn  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/chfn'" tppabs="http://shellbaike.com/cmd/chfn">chfn</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/chgrp  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/chgrp'" tppabs="http://shellbaike.com/cmd/chgrp">chgrp</a></li>
        
        <li class="tagItem"><a href="javascript:if(confirm('http://shellbaike.com/cmd/chkconfig  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/chkconfig'" tppabs="http://shellbaike.com/cmd/chkconfig">chkconfig</a></li>
        
    </ul>
    <div class="clear"></div>
</div>
            <br/>
<script type="text/javascript">
    document.write('<a style="display:none!important" id="tanx-a-mm_12741493_8680874_29282972"></a>');
    tanx_s = document.createElement("script");
    tanx_s.type = "text/javascript";
    tanx_s.charset = "gbk";
    tanx_s.id = "tanx-s-mm_12741493_8680874_29282972";
    tanx_s.async = true;
    tanx_s.src = "../../p.tanx.com/ex-i=mm_12741493_8680874_29282972"/*tpa=http://p.tanx.com/ex?i=mm_12741493_8680874_29282972*/;
    tanx_h = document.getElementsByTagName("head")[0];
    if(tanx_h)tanx_h.insertBefore(tanx_s,tanx_h.firstChild);
</script>
        </div>
        <div class="clear"></div>
    </div>
</div>
<div class="links">
    <div class="wrapper">
        <h3>友情链接</h3>
        <hr>
        <ul>
            <li>
                <a href="javascript:if(confirm('http://shellbaike.com/cmd/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://shellbaike.com/cmd/'" tppabs="http://shellbaike.com/cmd/" title="Linux命令大全" target="_blank">Linux命令大全</a>
            </li>
            <li>
                <a href="javascript:if(confirm('http://zhikanlouzhu.com/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://zhikanlouzhu.com/'" tppabs="http://zhikanlouzhu.com/" title="只看楼主网 - 最专业的只看楼主精品帖子网站" target="_blank">只看楼主网</a>
            </li>
            <li>
                <a href="javascript:if(confirm('http://luceneapi.com/  \n\nļ޷ Jeff Chou , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://luceneapi.com/'" tppabs="http://luceneapi.com/" title="Lucene API - 最全的Lucene教程、Lucene入门、Lucene API、Lucene资料网站" target="_blank">Lucene API</a>
            </li>
        </ul>
        <div class="clear"></div>
    </div>
</div>
<div id="footer">
    <div class="wrapper" style="text-align: center;">
        <p>&copy; SHELL 百科</p><br/>
        <p class="info">最全linux命令大全 Shell脚本编程技巧分享</p>
        <br/>
        <p>
            <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254040888'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/stat.php%3Fid%3D1254040888%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
        </p>
        <br/>
        <br/>
    </div>
</div>
<script type="text/javascript" src="../static/js/jquery.min.js" tppabs="http://shellbaike.com/static/js/jquery.min.js"></script>
<script type="text/javascript" src="../static/js/main.js" tppabs="http://shellbaike.com/static/js/main.js"></script>
<script type="text/javascript" src="../static/js/prism_pre.js" tppabs="http://shellbaike.com/static/js/prism_pre.js"></script>
<script type="text/javascript" >
    $(function(){
        $(".smartTime").smartTime();
        $(".mainInfo").dblclick(function(){
            $("html , body").animate({scrollTop:"0"}, 0);
        });
    });
</script>
</body>
</html>